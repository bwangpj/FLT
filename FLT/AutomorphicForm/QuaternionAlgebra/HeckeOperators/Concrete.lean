/-
Copyright (c) 2025 Kevin Buzzard. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kevin Buzzard, Andrew Yang, Matthew Jasper
-/
import FLT.AutomorphicForm.QuaternionAlgebra.HeckeOperators.Abstract -- abstract Hecke ops
import FLT.AutomorphicForm.QuaternionAlgebra.Defs -- definitions of automorphic forms
import FLT.QuaternionAlgebra.NumberField -- rigidifications of quat algs
import Mathlib.NumberTheory.NumberField.InfinitePlace.TotallyRealComplex
import Mathlib.RingTheory.DedekindDomain.FiniteAdeleRing
import FLT.DedekindDomain.FiniteAdeleRing.LocalUnits -- for (œÄ 0; 0 1)
import FLT.Mathlib.Topology.Algebra.RestrictedProduct
/-

# Concrete Hecke operators

Hecke operators for spaces of automorphic forms on totally definite quaternion algebras
of level `U‚ÇÅ(S)`, where `S` is a finite set of finite places of the totally real number
field `F`, and `U‚ÇÅ(S)` is the matrices which are of the form `(a *;0 a)` mod `v` for
all `v ‚àà S`.

## Main definitions

All in the `TotallyDefiniteQuaternionAlgebra.WeightTwoAutomorphicForm` namespace.

Let `r : Rigidification F D` be an `ùî∏_F^‚àû`-algebra isomorphism `D ‚äó[F] ùî∏_F^‚àû = M‚ÇÇ(ùî∏_F^‚àû)`,
needed to interpret the local factors `D·µ•` as matrix rings so we can define Hecke operators
as matrices.

* `HeckeOperator.T r R v` -- the Hecke operator `T·µ•` associated to `(œñ·µ• 0; 0 1)` at a (good)
  place `v` (via the rigidification `r`), as an `R`-linear endomorphism of
  `WeightTwoAutomorphicFormOfLevel (U1 r S) R`.
* `HeckeOperator.U r S R a ha` -- the Hecke operator `U·µ•,‚Çê` associated to `(a 0;0 1)` at
  a (bad) place `v`; here `a : v.adicCompletionIntegers F` and `ha` is a proof that `a ‚â† 0`,
  as an `R`-linear endomorphism of `WeightTwoAutomorphicFormOfLevel (U1 r S) R`.
* `HeckeAlgebra F D r S R` -- the Hecke algebra generated by the `T·µ•` and `U·µ•,‚Çê`. Built
  as a type, coerced from a subalgebra of the endomorphism algebra of the forms.
* `HeckeAlgebra.T D r R v hv` -- `T·µ•` as a term of type `HeckeAlgebra F D r S R`
* `HeckeAlgebra.U D r R v hv a ha` -- `U·µ•,‚Çê` as a term of type `HeckeAlgebra F D r S R`

-/

/-

## A finiteness result

The existence of abstract Hecke operators relies on a certain double coset space being
a finite union of single cosets. In our situation we can supply this finiteness proof
via a topological argument, which we abstract here.

-/

section finiteness

open Topology Set

variable {G : Type*} [Group G] [TopologicalSpace G] [IsTopologicalGroup G]
    {g : G} {U V : Subgroup G}

open scoped Pointwise in
lemma QuotientGroup.mk_image_finite_of_compact_of_open (hU : IsCompact (U : Set G))
    (hV : IsCompact (V : Set G)) (hVopen : IsOpen (V : Set G)) :
    (QuotientGroup.mk '' (U * g ‚Ä¢ V) : Set (G ‚ß∏ V)).Finite := by
  have : DiscreteTopology (G ‚ß∏ V) := by
    rw [‚Üê forall_open_iff_discrete]
    intro s
    rw [‚Üê (isQuotientMap_mk V).isOpen_preimage, ‚Üê (QuotientGroup.mk_surjective).image_preimage s,
      preimage_image_mk_eq_iUnion_image, iUnion_subtype]
    conv in ‚ãÉ x ‚àà _, _ => change ‚ãÉ x ‚àà (V : Set G), _
    rw [iUnion_mul_right_image]
    exact IsOpen.mul_left hVopen
  exact ((hU.mul <| hV.image (by fun_prop)).image continuous_mk).finite_of_discrete

end finiteness


open NumberField IsQuaternionAlgebra.NumberField IsDedekindDomain

-- let F be a totally real number field
variable (F : Type*) [Field F] [NumberField F] [IsTotallyReal F]

-- Let D/F be a quaternion algebra
variable (D : Type*) [Ring D] [Algebra F D] [IsQuaternionAlgebra F D]

-- Let r be a rigidification of D, which is a collection of isomorphisms D ‚äó F·µ• = M‚ÇÇ(F·µ•)
-- for all finite places v of F, compatible with the adelic structure (i.e. inducing
-- an isomorphism D ‚äó_F ùî∏_F^f = M‚ÇÇ(ùî∏_F^f))
variable (r : Rigidification F D)

-- Let S be a finite set of finite places of F (the level)
variable (S : Finset (HeightOneSpectrum (ùìû F)))

-- let P be a good prime
variable {P : HeightOneSpectrum (ùìû F)} (hP : P ‚àâ S)

open TotallyDefiniteQuaternionAlgebra
-- let's do T_P : S_2^D(U_1(S)) -> S_2^D(U_1(S))
namespace TotallyDefiniteQuaternionAlgebra.WeightTwoAutomorphicForm

open IsDedekindDomain.HeightOneSpectrum

open scoped TensorProduct

variable {F D} in
open scoped TensorProduct.RightActions in
/-- U1(S) -/
noncomputable abbrev U1 : Subgroup (D ‚äó[F] (IsDedekindDomain.FiniteAdeleRing (ùìû F) F))À£ :=
  Subgroup.map (Units.map r.symm.toMonoidHom) (GL2.TameLevel S)

variable {F D} in
open scoped TensorProduct.RightActions in
lemma U1_compact : IsCompact (U1 r S : Set (D ‚äó[F] (IsDedekindDomain.FiniteAdeleRing (ùìû F) F))À£) :=
  sorry -- #583, long

variable {F D} in
open scoped TensorProduct.RightActions in
lemma U1_open : IsOpen (U1 r S : Set (D ‚äó[F] (IsDedekindDomain.FiniteAdeleRing (ùìû F) F))À£) :=
  sorry -- #583, long

variable (R : Type*) [CommRing R]

namespace HeckeOperator

variable {F D S} in
set_option maxSynthPendingDepth 1 in
open scoped TensorProduct.RightActions in
/-- The Hecke operator T_v as an R-linear map from R-valued quaternionic weight 2
automorphic forms of level U_1(S).
-/
noncomputable def T (v : HeightOneSpectrum (ùìû F)) :
    WeightTwoAutomorphicFormOfLevel (U1 r S) R ‚Üí‚Çó[R]
    WeightTwoAutomorphicFormOfLevel (U1 r S) R :=
  letI : DecidableEq (HeightOneSpectrum (ùìû F)) := Classical.typeDecidableEq _
  let g : (D ‚äó[F] (IsDedekindDomain.FiniteAdeleRing (ùìû F) F))À£ :=
    Units.map r.symm.toMonoidHom (Matrix.GeneralLinearGroup.diagonal
    ![FiniteAdeleRing.localUniformiserUnit F v, 1])
  AbstractHeckeOperator.HeckeOperator (R := R) g (U1 r S) (U1 r S)
  (QuotientGroup.mk_image_finite_of_compact_of_open (U1_compact r S) (U1_compact r S) (U1_open r S))

variable {F D} in
set_option maxSynthPendingDepth 1 in
open scoped TensorProduct.RightActions in
/-- The Hecke operator U_{v,Œ±} associated to the matrix (Œ± 0;0 1) at v,
considered as an R-linear map from R-valued quaternionic weight 2
automorphic forms of level U_1(S). Here Œ± is a nonzero element of ùìû·µ•.
We do not demand the condition v ‚àà S, the bad primes, but this operator
should only be used in this setting. See also `T r v` for the good primes.
-/
noncomputable def U {v : HeightOneSpectrum (ùìû F)}
    (Œ± : v.adicCompletionIntegers F) (hŒ± : Œ± ‚â† 0) :
    WeightTwoAutomorphicFormOfLevel (U1 r S) R ‚Üí‚Çó[R]
    WeightTwoAutomorphicFormOfLevel (U1 r S) R :=
  letI : DecidableEq (HeightOneSpectrum (ùìû F)) := Classical.typeDecidableEq _
  let g : (D ‚äó[F] (IsDedekindDomain.FiniteAdeleRing (ùìû F) F))À£ :=
    Units.map r.symm.toMonoidHom (Matrix.GeneralLinearGroup.diagonal
    ![FiniteAdeleRing.localUnit F ‚ü®(Œ± : v.adicCompletion F),
    (Œ± : v.adicCompletion F)‚Åª¬π, by
      rw [mul_inv_cancel‚ÇÄ]
      exact_mod_cast hŒ±, by
      rw [inv_mul_cancel‚ÇÄ]
      exact_mod_cast hŒ±‚ü©, 1])
  AbstractHeckeOperator.HeckeOperator (R := R) g (U1 r S) (U1 r S)
  (QuotientGroup.mk_image_finite_of_compact_of_open (U1_compact r S) (U1_compact r S) (U1_open r S))

lemma _root_.Ne.mul {M‚ÇÄ : Type*} [Mul M‚ÇÄ] [Zero M‚ÇÄ] [NoZeroDivisors M‚ÇÄ] {a b : M‚ÇÄ}
  (ha : a ‚â† 0) (hb : b ‚â† 0) : a * b ‚â† 0 := mul_ne_zero ha hb

open scoped Pointwise

section CosetComputation
-- local F_v

-- set_option synthInstance.maxHeartbeats 0

variable (v : HeightOneSpectrum (ùìû F))
variable (Œ± : v.adicCompletionIntegers F)
variable (hŒ± : Œ± ‚â† 0)

variable {F Œ± hŒ±} in
noncomputable def U1v : Subgroup (GL (Fin 2) (adicCompletion F v)) := (GL2.localTameLevel v)

variable {F v} in
noncomputable def g : (GL (Fin 2) (adicCompletion F v)) :=
  Matrix.GeneralLinearGroup.diagonal (![‚ü®(Œ± : v.adicCompletion F),
    (Œ± : v.adicCompletion F)‚Åª¬π, by
      rw [mul_inv_cancel‚ÇÄ]
      exact_mod_cast hŒ±, by
      rw [inv_mul_cancel‚ÇÄ]
      exact_mod_cast hŒ±‚ü©, 1])

set_option synthInstance.maxHeartbeats 0 in
-- double coset space
variable {F v} in
noncomputable def doubleCosets :
  Set ((GL (Fin 2) (adicCompletion F v)) ‚ß∏ ‚Üë(U1v v)) :=
  (QuotientGroup.mk '' ((U1v v) * g Œ± hŒ± ‚Ä¢ ‚Üë(U1v v) ))

variable {F v} in
noncomputable def gt (t : v.adicCompletionIntegers F) : (GL (Fin 2) (adicCompletion F v)) := by
  let gtInv : Invertible !![(Œ± : v.adicCompletion F), t; 0, 1].det :=
  { invOf := (Œ± : v.adicCompletion F)‚Åª¬π,
    invOf_mul_self :=
      by simp only [Matrix.det_fin_two_of,
        mul_one, mul_zero, sub_zero]; rw [inv_mul_cancel‚ÇÄ]; exact_mod_cast hŒ±,
    mul_invOf_self :=
      by simp only [Matrix.det_fin_two_of,
        mul_one, mul_zero, sub_zero]; rw [mul_inv_cancel‚ÇÄ]; exact_mod_cast hŒ± }
  exact Matrix.unitOfDetInvertible !![(Œ± : v.adicCompletion F), t; 0, 1]

variable {F v Œ± hŒ±} in
noncomputable def ht (t : v.adicCompletion F) : (GL (Fin 2) (adicCompletion F v)) := by
  let htInv : Invertible !![1, t; 0, 1].det :=
  { invOf := 1,
    invOf_mul_self :=
      by simp only [Matrix.det_fin_two_of, mul_one, mul_zero, sub_zero],
    mul_invOf_self :=
      by simp only [Matrix.det_fin_two_of, mul_one, mul_zero, sub_zero] }
  exact Matrix.unitOfDetInvertible !![1, t; 0, 1]

variable {F v} in
noncomputable def singleCosetsFunction
  (t : ‚Üë(adicCompletionIntegers F v) ‚ß∏ (AddSubgroup.map (AddMonoidHom.mulLeft Œ±)
    (‚ä§ : AddSubgroup ‚Üë(adicCompletionIntegers F v)))) :
  ((GL (Fin 2) (adicCompletion F v)) ‚ß∏ ‚Üë(U1v v)) := by
  let tLift : ‚Üë(adicCompletionIntegers F v) := Quotient.out t
  exact QuotientGroup.mk (gt Œ± hŒ± tLift)

set_option maxHeartbeats 400000
-- explicit matrix coset computations
variable {F v} in
lemma U_coset : Set.BijOn (singleCosetsFunction Œ± hŒ±) ‚ä§ (doubleCosets Œ± hŒ±) := by
  have r (A : Matrix (Fin 2) (Fin 2) (adicCompletion F v)) [Invertible A.det] :
    (‚Üë(A.unitOfDetInvertible) : Matrix (Fin 2) (Fin 2) (adicCompletion F v)) = A := rfl
  constructor
  ¬∑ intro t h
    have m : (gt Œ± hŒ± (Quotient.out t)) =  ht ‚Üë(Quotient.out t) * g Œ± hŒ± := by
        have r‚ÇÅ : (g Œ± hŒ± : Matrix (Fin 2) (Fin 2) (adicCompletion F v))
          = !![‚ÜëŒ±, 0; 0, 1] := by
          rw[g]
          ext i j
          rw[Matrix.GeneralLinearGroup.diagonal]
          fin_cases i
          ¬∑ fin_cases j
            ¬∑ simp
            simp
          fin_cases j
          ¬∑ simp
          simp
        ext i j; push_cast
        rw[gt, ht, r‚ÇÅ]
        rw[r, r]
        rw[Matrix.mul_apply]
        simp only [Fin.sum_univ_two, Fin.isValue]
        fin_cases i
        ¬∑ fin_cases j
          ¬∑ simp
          simp
        simp
    rw[singleCosetsFunction, m, doubleCosets]
    use (ht ‚Üë(Quotient.out t) * g Œ± hŒ±)
    constructor
    ¬∑ use ht ‚Üë(Quotient.out t)
      constructor
      ¬∑ rw[ht]
        constructor
        ¬∑ let htInt : ((Matrix (Fin 2) (Fin 2) ‚Ü•(adicCompletionIntegers F v))À£) := by
            let htInv : Invertible !![1, (Quotient.out t); 0, 1].det :=
            { invOf := 1,
              invOf_mul_self :=
              by simp only [Matrix.det_fin_two_of, mul_one, mul_zero, sub_zero],
              mul_invOf_self :=
              by simp only [Matrix.det_fin_two_of, mul_one, mul_zero, sub_zero] }
            exact Matrix.unitOfDetInvertible !![1, (Quotient.out t); 0, 1]
          use htInt
          refine Units.eq_iff.mp ?_
          rw[r]
          have ho : (htInt = !![1, (Quotient.out t); 0, 1]) := rfl
          rw[Units.coe_map, ho]
          simp only [RingHom.toMonoidHom_eq_coe, MonoidHom.coe_coe, RingHom.mapMatrix_apply,
            ValuationSubring.coe_subtype]
          ext i j
          fin_cases i
          ¬∑ fin_cases j
            ¬∑ simp
            simp
          fin_cases j
          ¬∑ simp
          simp
        rw[r]
        simp
      use g Œ± hŒ±
      simp only [and_true]
      use (1 : GL (Fin 2) (adicCompletion F v))
      simp only [SetLike.mem_coe, smul_eq_mul, mul_one, and_true]
      exact Subgroup.one_mem (U1v v)
    rfl

  constructor
  ¬∑ intro t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ h
    rw[singleCosetsFunction, singleCosetsFunction] at h
    have h‚ÇÄ := QuotientGroup.eq.mp h
    have m : (gt Œ± hŒ± (Quotient.out t‚ÇÅ))‚Åª¬π * gt Œ± hŒ± (Quotient.out t‚ÇÇ)
      = ht ((Œ± : v.adicCompletion F)‚Åª¬π *
        (( - (Quotient.out t‚ÇÅ) + (Quotient.out t‚ÇÇ)) : adicCompletion F v )) := by
        apply inv_mul_eq_iff_eq_mul.mpr
        rw [gt, gt, ht]
        ext i j; push_cast
        rw[r, r, r]
        rw[Matrix.mul_apply]
        simp only [Fin.sum_univ_two, Fin.isValue]
        fin_cases i
        ¬∑ fin_cases j
          ¬∑ simp
          simp only [Fin.zero_eta, Fin.isValue, Fin.mk_one, Matrix.of_apply, Matrix.cons_val',
            Matrix.cons_val_one, Matrix.cons_val_fin_one, Matrix.cons_val_zero, mul_one]
          rw[‚Üê mul_assoc, mul_inv_cancel‚ÇÄ, one_mul]; ring
          have hŒ±‚ÇÅ := Subtype.coe_ne_coe.mpr hŒ±; assumption
        simp
    rw[m] at h‚ÇÄ
    obtain ‚ü® ‚ü® x, y ‚ü© , z ‚ü© := h‚ÇÄ
    apply_fun (fun (A : (Matrix (Fin 2) (Fin 2) (adicCompletion F v))À£) ‚Ü¶ A 0 1) at y
    rw[ht] at y
    simp only [RingHom.toMonoidHom_eq_coe, Fin.isValue, Units.coe_map, MonoidHom.coe_coe,
      RingHom.mapMatrix_apply, ValuationSubring.coe_subtype, Matrix.map_apply] at y
    have w : ((x 0 1) : adicCompletion F v) = (Œ± : v.adicCompletion F)‚Åª¬π *
        (( - (Quotient.out t‚ÇÅ) + (Quotient.out t‚ÇÇ)) : adicCompletion F v ) := by
        rw[y]; rfl
    conv_lhs =>
      apply Eq.symm (QuotientAddGroup.out_eq' t‚ÇÅ)
    conv_rhs =>
      apply Eq.symm (QuotientAddGroup.out_eq' t‚ÇÇ)
    apply QuotientAddGroup.eq.mpr
    use (x 0 1)
    constructor
    ¬∑ simp
    simp only [Fin.isValue, AddMonoidHom.coe_mulLeft]
    apply (Subtype.coe_inj).mp; push_cast
    rw[w, ‚Üê mul_assoc, mul_inv_cancel‚ÇÄ, one_mul]
    have hŒ±‚ÇÅ := Subtype.coe_ne_coe.mpr hŒ±; assumption

  intro co h
  obtain ‚ü® co‚ÇÄ, ‚ü® ‚ü® co‚ÇÅ, h‚ÇÅ, ‚ü® l, ‚ü® ‚ü® co‚ÇÇ, ‚ü® h‚ÇÇ, z ‚ü© ‚ü© , hl ‚ü© ‚ü© ‚ü© , h‚ÇÄ ‚ü© ‚ü© := h
  have hp : co‚ÇÄ = co‚ÇÅ * (g Œ± hŒ±) * co‚ÇÇ := by
    rw[‚Üê hl, ‚Üê z]; simp only [smul_eq_mul]; rw[mul_assoc]
  obtain ‚ü® ‚ü® ‚ü® val_x‚ÇÅ, inv_x‚ÇÅ, val_inv_x‚ÇÅ, inv_val_x‚ÇÅ ‚ü© , y ‚ü© , z ‚ü© := h‚ÇÅ
  let a : (adicCompletionIntegers F v) := (val_x‚ÇÅ 0 0)
  let b : (adicCompletionIntegers F v) := (val_x‚ÇÅ 0 1)
  let c : (adicCompletionIntegers F v) := (val_x‚ÇÅ 1 0)
  let d : (adicCompletionIntegers F v) := (val_x‚ÇÅ 1 1)
  have h11 : c * (inv_x‚ÇÅ 0 1) + d * (inv_x‚ÇÅ 1 1) = 1 := by calc
    _ = (val_x‚ÇÅ 1 0) * (inv_x‚ÇÅ 0 1) + (val_x‚ÇÅ 1 1) * (inv_x‚ÇÅ 1 1) := rfl
    _ = (val_x‚ÇÅ * inv_x‚ÇÅ) 1 1 := by rw[Matrix.mul_apply]; simp
    _ = 1 := by rw[val_inv_x‚ÇÅ]; simp
  have valc : Valued.v (c : adicCompletion F v) < 1 := by
    have hc : c = (val_x‚ÇÅ 1 0) := rfl
    rw[hc]
    apply_fun (fun (A : (Matrix (Fin 2) (Fin 2) (adicCompletion F v))À£) ‚Ü¶ A 1 0) at y
    simp only [RingHom.toMonoidHom_eq_coe, Units.map_mk, MonoidHom.coe_coe, RingHom.mapMatrix_apply,
      ValuationSubring.coe_subtype, Fin.isValue, Matrix.map_apply] at y
    rw[y]
    apply z.right
  have maxc : c ‚àà IsLocalRing.maximalIdeal (adicCompletionIntegers F v) := by
    apply (ValuationSubring.valuation_lt_one_iff (adicCompletionIntegers F v) c).mpr
    have valc‚ÇÅ : Valued.v.IsEquiv (adicCompletionIntegers F v).valuation := by
      apply Valuation.isEquiv_valuation_valuationSubring
    apply (Valuation.isEquiv_iff_val_lt_one.mp valc‚ÇÅ).mp
    exact valc
  have maxd : d ‚àâ IsLocalRing.maximalIdeal (adicCompletionIntegers F v) := by
    by_contra maxd‚ÇÅ
    have max1 : c * (inv_x‚ÇÅ 0 1) + d * (inv_x‚ÇÅ 1 1)
      ‚àà IsLocalRing.maximalIdeal (adicCompletionIntegers F v) := by
      apply Ideal.add_mem
      repeat
        apply Ideal.mul_mem_right
        assumption
    rw[h11] at max1
    have nonunit : 1 ‚àà nonunits ‚Ü•(adicCompletionIntegers F v) :=
      (IsLocalRing.mem_maximalIdeal 1).mp max1
    exact one_notMem_nonunits nonunit
  have dunit : IsUnit d := by
    by_contra dnotunit
    have dnonunit : d ‚àà nonunits ‚Ü•(adicCompletionIntegers F v) := mem_nonunits_iff.mpr dnotunit
    have dmax : d ‚àà IsLocalRing.maximalIdeal (adicCompletionIntegers F v) :=
      (IsLocalRing.mem_maximalIdeal d).mpr dnonunit
    exact maxd dmax
  obtain ‚ü® dinv, dvalinv, dinvval ‚ü© := isUnit_iff_exists.mp dunit

  let t : ‚Ü•(adicCompletionIntegers F v) ‚ß∏ AddSubgroup.map (AddMonoidHom.mulLeft Œ±) ‚ä§ := b * dinv
  use t
  simp only [Set.top_eq_univ, Set.mem_univ, true_and]
  rw[singleCosetsFunction, ‚Üê h‚ÇÄ]
  apply QuotientGroup.eq.mpr
  rw[hp, ‚Üê mul_assoc]
  have uele (u‚ÇÅ : GL (Fin 2) (adicCompletion F v)) (hu‚ÇÅ : u‚ÇÅ ‚àà U1v v)
    (u‚ÇÇ : GL (Fin 2) (adicCompletion F v)) (hu‚ÇÇ : u‚ÇÇ ‚àà U1v v) :
    u‚ÇÅ * u‚ÇÇ ‚àà U1v v := by
    exact (Subgroup.mul_mem_cancel_right (U1v v) hu‚ÇÇ).mpr hu‚ÇÅ
  have ht : t = b * dinv := rfl
  rw[‚Üê QuotientAddGroup.out_eq' t] at ht
  have ht‚ÇÅ := QuotientAddGroup.eq.mp ht
  obtain ‚ü®q, hq‚ü© := ht‚ÇÅ
  simp only [AddSubgroup.coe_top, Set.mem_univ, AddMonoidHom.coe_mulLeft, true_and] at hq
  have hq‚ÇÅ : Quotient.out t = b * dinv - Œ± * q := by rw[hq]; ring
  apply uele
  ¬∑ let muMatrix : Matrix (Fin 2) (Fin 2) (adicCompletion F v) :=
      !![a-(Quotient.out t)*c, (Œ± : adicCompletion F v)‚Åª¬π * (b-(Quotient.out t)*d); c*Œ±, d]
    let mup : GL (Fin 2) (adicCompletion F v) := (gt Œ± hŒ± (Quotient.out t))‚Åª¬π * (co‚ÇÅ * g Œ± hŒ±)
    have hmup : mup = (gt Œ± hŒ± (Quotient.out t))‚Åª¬π * (co‚ÇÅ * g Œ± hŒ±) := rfl
    have m : mup = muMatrix := by
      have hp1 : (gt Œ± hŒ± (Quotient.out t))‚Åª¬π
        = !![(Œ± : adicCompletion F v)‚Åª¬π, -(Œ± : adicCompletion F v)‚Åª¬π*(Quotient.out t);0,1] := by
        rw[gt]
        push_cast; rw[r]
        rw[Matrix.inv_def]
        simp only [Matrix.det_fin_two_of, mul_one, mul_zero, sub_zero, Ring.inverse_eq_inv',
          Matrix.adjugate_fin_two_of, neg_zero, Matrix.smul_of, Matrix.smul_cons, smul_eq_mul,
          mul_neg, Matrix.smul_empty, neg_mul, EmbeddingLike.apply_eq_iff_eq]
        rw [inv_mul_cancel‚ÇÄ]; exact_mod_cast hŒ±
      have hp2 : co‚ÇÅ = !![(a : adicCompletion F v),b;c,d] := by
        rw[‚Üê y]
        ext i j
        simp only [RingHom.toMonoidHom_eq_coe, Units.map_mk, MonoidHom.coe_coe,
          RingHom.mapMatrix_apply, ValuationSubring.coe_subtype, Matrix.map_apply, Matrix.of_apply,
          Matrix.cons_val', Matrix.cons_val_fin_one]
        fin_cases i
        ¬∑ fin_cases j
          ¬∑ simp; rfl
          simp; rfl
        fin_cases j
        ¬∑ simp; rfl
        simp; rfl
      have hp3 : g Œ± hŒ± = !![(Œ± : adicCompletion F v), 0;0,1] := by
        rw[g]
        ext i j
        simp only [Matrix.of_apply, Matrix.cons_val', Matrix.cons_val_fin_one]
        fin_cases i
        ¬∑ fin_cases j
          ¬∑ simp; rfl
          simp; rfl
        fin_cases j
        ¬∑ simp; rfl
        simp; rfl
      rw[hmup]; push_cast; rw[hp2, hp3]
      norm_cast; rw[hp1]
      unfold muMatrix
      simp only [neg_mul, Matrix.cons_mul, Nat.succ_eq_add_one, Nat.reduceAdd, Matrix.vecMul_cons,
        Matrix.head_cons, Matrix.smul_cons, smul_eq_mul, mul_zero, Matrix.smul_empty,
        Matrix.tail_cons, mul_one, Matrix.empty_vecMul, add_zero, Matrix.add_cons, zero_add,
        Matrix.empty_add_empty, Matrix.empty_mul, Equiv.symm_apply_apply, neg_smul, Matrix.neg_cons,
        Matrix.neg_empty, zero_smul, one_smul, EmbeddingLike.apply_eq_iff_eq]
      ring_nf
      ext i j
      fin_cases i
      ¬∑ fin_cases j
        ¬∑ simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.zero_eta, Fin.isValue,
          Matrix.cons_val', Matrix.cons_val_zero, Matrix.cons_val_fin_one]
          rw [mul_inv_cancel‚ÇÄ]
          ¬∑ simp
          exact_mod_cast hŒ±
        simp
      fin_cases j
      ¬∑ simp
      simp

    rw[‚Üê hmup]

    let muMatrixInt : Matrix (Fin 2) (Fin 2) (adicCompletionIntegers F v) :=
      !![a-(Quotient.out t)*c, q*d; c*Œ±, d]
    have inteq : (RingHom.mapMatrix ((v.adicCompletionIntegers F).subtype)).toMonoidHom
      muMatrixInt = muMatrix := by
      simp only [RingHom.toMonoidHom_eq_coe, MonoidHom.coe_coe, RingHom.mapMatrix_apply,
        ValuationSubring.coe_subtype]
      unfold muMatrixInt muMatrix
      ext i j
      fin_cases i
      ¬∑ fin_cases j
        ¬∑ simp
        simp only [Fin.zero_eta, Fin.isValue, Fin.mk_one, Matrix.map_apply, Matrix.of_apply,
          Matrix.cons_val', Matrix.cons_val_one, Matrix.cons_val_fin_one, Matrix.cons_val_zero,
          MulMemClass.coe_mul]
        rw[hq‚ÇÅ]
        ring_nf
        sorry -- algebra
      fin_cases j
      ¬∑ simp
      simp
    rw[‚Üê m] at inteq

    constructor
    ¬∑ -- image of unit
      sorry
    -- in localTameLevel
    sorry
  assumption


end CosetComputation

lemma U_mul {v : HeightOneSpectrum (ùìû F)}
    {Œ± Œ≤ : v.adicCompletionIntegers F} (hŒ± : Œ± ‚â† 0) (hŒ≤ : Œ≤ ‚â† 0) :
    (U r S R Œ± hŒ± ‚àò‚Çó U r S R Œ≤ hŒ≤) =
    U r S R (Œ± * Œ≤) (hŒ±.mul hŒ≤) := by
  ext a
  rw[U, U, U]
  simp only [MulEquiv.toMonoidHom_eq_coe, LinearMap.coe_comp, Function.comp_apply,
    MulMemClass.coe_mul, mul_inv_rev]
  apply (Subtype.coe_inj).mp
  conv_rhs =>
    apply AbstractHeckeOperator.HeckeOperator_apply
  conv_lhs =>
    apply AbstractHeckeOperator.HeckeOperator_apply
  conv_lhs =>
    arg 1; ext; arg 1; ext; arg 2;
    apply AbstractHeckeOperator.HeckeOperator_apply
  #check U_coset Œ± hŒ±
  #check RestrictedProduct.mem_coset_and_mulSupport_subset_of_isProductAt

  sorry

lemma U_comm {v : HeightOneSpectrum (ùìû F)}
    {Œ± Œ≤ : v.adicCompletionIntegers F} (hŒ± : Œ± ‚â† 0) (hŒ≤ : Œ≤ ‚â† 0) :
    U r S R Œ± hŒ± ‚àò‚Çó U r S R Œ≤ hŒ≤ =
    U r S R Œ≤ hŒ≤ ‚àò‚Çó U r S R Œ± hŒ± := by
  rw [U_mul, U_mul]
  congr 1
  rw [mul_comm]

end HeckeOperator

open HeckeOperator

/-- `HeckeAlgebra F D r S R` is the Hecke algebra associated to the weight 2
`R`-valued automorphic forms associated to the discriminant 1 totally definite
quaternion algebra `D` over the totally real field `F`, of level `U‚ÇÅ(S)` where `S` is
a finite set of nonzero primes `v` of `ùìû F`. To make sense of this definition we choose
a rigidification `r`, that is, a fixed `ùî∏_F^‚àû`-linear
isomorphism `D ‚äó[F] ùî∏_F^‚àû = M‚ÇÇ(ùî∏_F^‚àû)`, enabling us to define level structures and
Hecke operators `T·µ•` and `U·µ•` using 2x2 matrices.

Details: `U‚ÇÅ(S)` is the subgroup of `(D ‚äó[F] ùî∏_F^‚àû)À£` associated, via `r`, to the
matrices which are in `GL‚ÇÇ(ùìû·µ•)` for all `v ‚àâ S` and which are of the form
`(a *; 0 a)` mod `v` for all `v ‚àà S`. The Hecke algebra is defined to be the
sub-`R`-algebra of the weight 2 forms of level `U‚ÇÅ(S)` generated by the following
two kinds of Hecke operators: first there are the operators
`T·µ•` associated to the matrices `(œñ·µ• 0; 0 1)` for `v ‚àâ S` (here `œñ·µ• ‚àà ùî∏_F^‚àû` is a local
uniformiser supported at `v`). Second, there are the Hecke operators `U·µ•,‚Çê`
for `v ‚àà S` and `0 ‚â† Œ±·µ• ‚àà ùìû·µ•`, associated the matries `(Œ±·µ• 0; 0 1)`.
These slightly nonstandard Hecke operators satisfy `U·µ•,‚Çõ * U·µ•,‚Çú = U·µ•,‚Çõ‚Çú`
and in particular this Hecke algebra is commutative (Hecke operators supported
at distinct primes commute because the decomposition of the double cosets
into single cosets can be done purely locally).
-/
def HeckeAlgebra : Type _ :=
  (Algebra.adjoin R ({T r R v | v ‚àâ S} ‚à™
  {œÜ | ‚àÉ (v : HeightOneSpectrum (ùìû F)) (_hv : v ‚àà S)
         (Œ± : v.adicCompletionIntegers F) (hŒ± : Œ± ‚â† 0), œÜ = U r S R Œ± hŒ±}) :
    Subalgebra R (WeightTwoAutomorphicFormOfLevel (U1 r S) R ‚Üí‚Çó[R]
      WeightTwoAutomorphicFormOfLevel (U1 r S) R))

namespace HeckeAlgebra

noncomputable instance instRing :
    Ring (HeckeAlgebra F D r S R) := inferInstanceAs <|
  Ring (Algebra.adjoin R _ : Subalgebra R (WeightTwoAutomorphicFormOfLevel (U1 r S) R ‚Üí‚Çó[R]
      WeightTwoAutomorphicFormOfLevel (U1 r S) R))

noncomputable instance instAlgebra :
    Algebra R (HeckeAlgebra F D r S R) := inferInstanceAs <|
  Algebra R (Algebra.adjoin R _ : Subalgebra R (WeightTwoAutomorphicFormOfLevel (U1 r S) R ‚Üí‚Çó[R]
      WeightTwoAutomorphicFormOfLevel (U1 r S) R))

noncomputable instance instCommRing :
    CommRing (HeckeAlgebra F D r S R) where
  __ := instRing F D r S R
  mul_comm := sorry -- #585 -- check on generators

variable {F S} in
/-- The Hecke operator T·µ• as an element of the Hecke algebra. -/
noncomputable def T (v : HeightOneSpectrum (ùìû F)) (hv : v ‚àâ S) : HeckeAlgebra F D r S R :=
  ‚ü®HeckeOperator.T r R v, by
    apply Algebra.subset_adjoin
    left
    use v‚ü©



variable {F S} in
/-- The Hecke operator U·µ•,‚Çê as an element of the Hecke algebra. -/
noncomputable def U (v : HeightOneSpectrum (ùìû F)) (hv : v ‚àà S) (Œ± : v.adicCompletionIntegers F)
    (hŒ± : Œ± ‚â† 0) : HeckeAlgebra F D r S R :=
  ‚ü®HeckeOperator.U r S R Œ± hŒ±, by
    apply Algebra.subset_adjoin
    right
    use v, hv, Œ±, hŒ±‚ü©

end HeckeAlgebra

end TotallyDefiniteQuaternionAlgebra.WeightTwoAutomorphicForm
